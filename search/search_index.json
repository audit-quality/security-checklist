{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>The open source knowledge repository for common smart contract bugs.</p> <p>The goal is to make a comprehensive checklist of common smart contract errors that can be used in many different contexts. This list intends to make it clearer what is an incorrect and correct pattern looks like to make it easier for anyone to better understand these common issues.</p> <p>Is something missing? Review the contributing guidelines and open a PR!</p>"},{"location":"#how-to-run-locally","title":"How to run locally","text":"<p>This project is built with MkDocs. To run the docs locally, install the Python <code>mkdocs-material</code> package with <code>pip install mkdocs-material</code> or <code>pip3 install mkdocs-material</code>. After the package is installed, navigate to the top level directory of this project and run <code>mkdocs serve</code>.</p>"},{"location":"#seriously-why-another-security-checklist","title":"Seriously, why another security checklist?!","text":"<p>This checklist of security issues in smart contracts aims to differentiate itself in a few ways:</p> <ol> <li>Seek community contributions rather than attempting a solo effort</li> <li>Give an explanation about what differentiates a correct implementation from an incorrect implementation, making it easier for anyone (security novices included) to avoid common errors</li> <li>Link to additional information related to each vulnerability</li> <li>Provide a nicer layout rendering than a markdown file</li> </ol>"},{"location":"AMM/","title":"AMM (Automated Market Maker)","text":"<p>AMMs allow for swapping between different tokens. Different AMMs have different designs and can involve different risks during integration.</p> <p>Other resources:</p> <ul> <li>None currently</li> </ul>"},{"location":"AMM/#1-is-there-a-user-defined-slippage-value-when-a-swap-happens","title":"1. Is there a user defined slippage value when a swap happens?","text":"<p>Incorrect</p> <p>No slippage protection during swaps, or the slippage amount is not user defined. Even if a slippage check exists, the implementation should be examined carefully.</p> <p>Correct</p> <p>The slippage amount is user defined, similar to the <code>amountOutMin</code> argument in the swapExactTokensForTokens function of UniswapV2Router02.sol.</p> <p>Explanation</p> <p>Slippage is a side-effect of how AMMs operate, meaning slippage is always present in a swap. If there is no slippage protection and the swap can proceed at any price, the swap can be sandwiched or arbitraged by MEV bots, resulting in the user receiving fewer tokens than expected. If there is slippage protection that is hardcoded by the protocol, the swap may revert when the market volatility is high or liquidity is low, resulting in a temporary denial of service for the user who is unable to perform the swap.</p> <p>Links</p> <ul> <li>Code4rena has many findings related to missing or inadequate slippage settings, including this one and this one.</li> </ul>"},{"location":"AMM/#2-if-a-single-sided-deposit-into-a-multi-token-pool-is-allowed-does-the-protocol-calculate-the-token-swap-amount-properly","title":"2. If a single-sided deposit into a multi-token pool is allowed, does the protocol calculate the token swap amount properly?","text":"<p>Incorrect</p> <p>No, the protocol naively swaps half the tokens received from the user and then deposits the tokens into the same pool that was used for the swapping process.</p> <p>Correct</p> <p>Yes, the protocol performs the proper math to prevent leftover dust or returns any leftover dust to the user after the deposit process.</p> <p>Explanation</p> <p>If a protocol takes the naive approach of swapping half of the token, this first swap will change the pool balances and exchange rate between the tokens in the pool. It is important to account for the impact of this swap when calculating the amount of tokens that should be swapped for a dust-free deposit into the liquidity pool. The precise math to allow a one-sided deposit into a Uniswap-like pool is detailed by Alpha Finance.</p> <p>Links</p> <ul> <li>Alpha Finance single token deposit derivation</li> <li>One-sided swap finding</li> </ul>"},{"location":"LSDs/","title":"LSDs (Liquid Staking Derivatives)","text":"<p>LSDs have become a popular way of earning interest on Proof of Stake (PoS) native token staking without locking up the staked tokens. A LSD protocol issues a new liquid token in return for staking the native tokens, which allows users to use their new token in other dApps.</p> <p>Other resources:</p> <ul> <li>Decurity LSD checklist</li> <li>Sigma Prime LSD checklist</li> </ul>"},{"location":"LSDs/#1-are-withdraw-credentials-securely-handled-to-prevent-a-malicious-node-operator-from-frontrunning-withdrawals-with-their-own-credentials","title":"1. Are withdraw credentials securely handled to prevent a malicious node operator from frontrunning withdrawals with their own credentials?","text":"<p>Incorrect</p> <p>No</p> <p>Correct</p> <p>Yes</p> <p>Explanation</p> <p>The process of setting <code>withdrawal_credentials</code>, a variable used in the beacon chain withdrawal process, is a key part in determining who receives the ETH upon withdrawal. The <code>withdrawal_credentials</code> value must match the key of a depositor. But if a malicious party frontruns a valid deposit from the staking pool with their own deposit of 32 ETH, the withdraw request can include the malicious party's own <code>withdrawal_credentials</code> and the malicious party will receive the ETH from the staking pool. This is made possible by the fact that the beacon chain deposit and withdrawal process allows multiple <code>withdrawal_credentials</code> based on the addresses of depositors.</p> <p>Links</p> <ul> <li>Lido and Rocketpool frontrunning bounty writeup</li> <li>Tranchess frontrunning bounty writeup</li> </ul>"},{"location":"commons-erc-tokens/","title":"Common ERC Tokens (ERC20, ERC4626)","text":"<p>ERC20 and other token standards, the different implementations of this standard do not all play nicely together. In addition, some ERC20 tokens do not follow the standard exactly.</p> <p>Other resources:</p> <ul> <li>https://ercx.runtimeverification.com/</li> </ul>"},{"location":"commons-erc-tokens/#1-are-incompatible-versions-of-this-erc-considered","title":"1. Are incompatible versions of this ERC considered?","text":"<p>Incorrect</p> <p>No</p> <p>Correct</p> <p>Yes</p> <p>Explanation</p> <p>This is an extremely broad category, but it is hard to enumerate every possible issue related to incompatibility. The best approach is to review the corresponding link below outlining unexpected behavior for each token standard. </p> <p>Links</p> <ul> <li>Unexpected or non-compliant ERC20 behavior</li> <li>Unexpected or non-compliant ERC4626 behavior</li> </ul>"},{"location":"commons-erc-tokens/#2-are-any-newly-created-erc-tokens-compliant-with-the-standard","title":"2. Are any newly created ERC tokens compliant with the standard?","text":"<p>Incorrect</p> <p>No</p> <p>Correct</p> <p>Yes</p> <p>Explanation</p> <p>Every ERC standard contains detailed information about what the contract code must do to remain compliant with the standard. If the contract is importing an ERC implementation from a well-known library, such a OpenZeppelin, there is less likelihood of unusual implementation details when compared to a fully custom ERC implementation.</p> <p>Links</p> <ul> <li>Slither ERC conformance check for ERC20, ERC4626, and many other token standards</li> </ul>"},{"location":"commons-erc-tokens/#3-if-tokens-with-openzeppelin-and-solmate-erc-imports-involved-are-incompatibilities-considered","title":"3. If tokens with OpenZeppelin and solmate ERC imports involved, are incompatibilities considered?","text":"<p>Incorrect</p> <p>No</p> <p>Correct</p> <p>Yes, the known compatibility issues have been considered</p> <p>Explanation</p> <p>Solmate's gas optimizations have led to some differences compared to tokens importing OpenZeppelin ERC libraries. Examples of this are linked to below.</p> <p>Links</p> <ul> <li>IERC20 incompatibility between OZ and solmate</li> <li><code>safeTransfer()</code> reverts on flashloan for certain tokens in solmate</li> <li>Missing maxwithdraw check in solmate</li> <li><code>totalAssets()</code> implementation inconsistency in solmate</li> </ul>"},{"location":"commons-erc-tokens/#4-if-solmate-is-used-is-there-an-existence-check-before-any-safetransfer","title":"4. If solmate is used, is there an existence check before any safeTransfer?","text":"<p>Incorrect</p> <p>No, and the lack of this check may cause problems</p> <p>Correct</p> <p>Yes</p> <p>Explanation</p> <p>Solmate delegates the responsibility of checking that a token has code to the caller, as stated in the SafeTransferLib NatSpec.</p> <p>Links</p> <ul> <li>Past Code4rena issues (1 and 2)</li> </ul>"},{"location":"compound-fork/","title":"Compound Finance v2 Forks","text":"<p>Compound Finance is a popular lending protocol that has been forked many times. Despite this popularity, there have been many hacks of Compound Forks due to common pitfalls.</p> <p>Other resources:</p> <ul> <li>List of Compound Finance fork hacks</li> </ul>"},{"location":"compound-fork/#1-what-is-the-process-for-adding-new-tokens","title":"1. What is the process for adding new tokens?","text":"<p>Incorrect</p> <p>No checks in place to prevent the addition of a ERC777 token</p> <p>Correct</p> <p>Validate that any token that will be added to the protocol has sufficient liquidity, a secure price oracle, is a standard ERC20 token without any callback hooks</p> <p>Explanation</p> <p>The Compound Finance codebase is vulnerable to reentrancy. This means that without a process to review new token markets (for example, this OpenZeppelin checklist), a token that risks a reentrancy attack or bad debt may be added</p> <p>Links</p> <ul> <li>CREAM hack with AMP token</li> <li>OpenZeppelin asset listing checklist</li> </ul>"},{"location":"compound-fork/#2-what-oracle-is-used-for-price-data","title":"2. What oracle is used for price data?","text":"<p>Incorrect</p> <p>Spot price of a Uniswap pool or any price data that can be manipulated with a flashloan</p> <p>Correct</p> <p>A decentralized oracle (Chainlink, Band, UMA, etc.), Uniswap v3 TWAP or similar</p> <p>Explanation</p> <p>Oracle price manipulation changes the health of each borrowed position and can lead to bad debt, especially when combined with flashloans</p> <p>Links</p> <ul> <li>Compound DAI liquidation</li> </ul>"},{"location":"compound-fork/#3-what-are-the-collateral-factors-and-borrowing-curves-used-for-different-tokens","title":"3. What are the collateral factors and borrowing curves used for different tokens?","text":"<p>Incorrect</p> <p>Much higher borrowing factor permitted compared to Compound (or Aave), much lower interest rate curve to Compound (or Aave)</p> <p>Correct</p> <p>Similar borrowing factor and interest rate curves to Compound (or Aave)</p> <p>Explanation</p> <p>The risk of bad debt is higher in adverse market conditions when there is a greater fraction of assets that is borrowed</p> <p>Links</p> <ul> <li>Compound's regular risk modelling with Gauntlet</li> </ul>"},{"location":"compound-fork/#4-what-mitigations-exist-to-mitigate-the-risk-of-a-toxic-liquidation-spiral","title":"4. What mitigations exist to mitigate the risk of a toxic liquidation spiral?","text":"<p>Incorrect</p> <p>None, the protocol did not consider this edge case in detail</p> <p>Correct</p> <p>Many options exist with varying degrees of impact: - Apply a dynamic incentive or closing factor during the liquidation process, which reduces the reward for liquidators as the loan nears the toxic liquidation threshold - Allow markets to be quickly (or automatically) frozen in certain market conditions, in line with this research - Choosing borrow caps and and collateral factors on assets strategically to minimize the risk of bad debt for each asset depending on current market liquidity and recent volatility</p> <p>Explanation</p> <p>Any DeFi protocol that allows borrowing must enforce liquidations to avoid the accumulation of bad debt. The most common incentive design is to give the liquidator a fraction of the liquidated amount as a reward. If there is a fast enough price movement, the reward amount given to the liquidator could create bad debt in the protocol, which can result in a liquidation spiral. This spiral is a result of one liquidation causing the borrower position to become less healthy (higher ratio of borrowed assets to collateral) after a liquidation happens, triggering more liquidations.</p> <p>Links</p> <ul> <li>CRV bad debt in Aave</li> <li>OpenZeppelin 2019 finding about \"Counterproductive Incentives\"</li> <li>Toxic liquidations whitepaper</li> <li>OVIX hack</li> </ul>"},{"location":"cryptography/","title":"Cryptography","text":"<p>Many cryptographic primitives are used by protocols. These can often have implementation mistakes when a common library is not used or when key values are improperly set.</p> <p>Other resources:</p> <ul> <li>None currently</li> </ul>"},{"location":"cryptography/#1-is-the-merkle-proof-validation-done-properly","title":"1. Is the Merkle proof validation done properly?","text":"<p>Incorrect</p> <p>No</p> <p>Correct</p> <p>Yes</p> <p>Explanation</p> <p>TODO and improve the focus of the question</p> <p>Links</p> <ul> <li>OpenSea Merkle Audit Finding</li> <li>Binance bridge vulnerability</li> <li>OpenZeppelin merkle multiproof vulnerability in OZ &gt;=4.7.0 &lt;4.9.2</li> </ul>"},{"location":"cryptography/#2-is-the-merkle-root-set-to-a-non-zero-value","title":"2. Is the Merkle root set to a non-zero value?","text":"<p>Incorrect</p> <p>No</p> <p>Correct</p> <p>Yes</p> <p>Explanation</p> <p>The default value of an integer in solidity is zero. So if valid proofs are stored in a mapping that maps the proof to the root, then invalid proofs map to a value of zero, which is the same as the valid root if the root is set to zero. This allows invalid proofs to be accepted because there is inadequate differentiation between valid and invalid proofs.</p> <p>Links</p> <ul> <li>Nomad bridge hack</li> </ul>"},{"location":"cryptography/#3-is-ecdsa-recover-malleable","title":"3. Is ECDSA <code>recover</code> malleable?","text":"<p>Incorrect</p> <p>No</p> <p>Correct</p> <p>Yes</p> <p>Explanation</p> <p>TODO and improve the focus of the question</p> <p>Links</p> <ul> <li>Deeper dive into ECDSA signature malleability</li> <li>Polygon $2 million bug bounty</li> <li>OpenZeppelin ECDSA recover vulnerability in OZ &gt;= 4.1.0 &lt; 4.7.3</li> <li>Signature malleability PoC</li> </ul>"},{"location":"cryptography/#4-is-the-result-of-soliditys-ecrecover-checked-for-a-return-value-of-0","title":"4. Is the result of solidity's <code>ecrecover</code> checked for a return value of 0?","text":"<p>Incorrect</p> <p>No, the return value from <code>ecrecover</code> is not checked for a value of 0.</p> <p>Correct</p> <p>Yes, the code will revert if <code>ecrecover</code> returns a value of 0.</p> <p>Explanation</p> <p>The solidity docs explain that <code>ecrecover</code> will return zero on error. If there is an error, the code should revert instead of continuing with the assumption that the recovered value is zero.</p> <p>Links</p> <ul> <li>Solidity docs describing ecrecover</li> <li>OpenZeppelin's ECDSA.sol <code>tryRecover()</code> avoids this issue as the comments explain</li> <li>Code4rena has many findings related to a missing zero check for ecrecover, including this one and this one.</li> </ul>"},{"location":"layer2/","title":"Deploying on other EVM-compatible (Arbitrum, Optimism, Gnosis, etc.)","text":"<p>Protocols that will be deployed on multiple chains may require custom modifications for each individual chain because each chain is slightly different in key ways. One common multichain deployment option is to deploy on mainnet Ethereum and an L2 like Arbitrum or Optimism.</p> <p>Other resources:</p> <ul> <li>EVM Diff, differences between EVM compatible chains</li> </ul>"},{"location":"layer2/#1-if-chainlink-is-used-is-there-a-check-for-sequencer-uptime","title":"1. If Chainlink is used, is there a check for sequencer uptime?","text":"<p>Incorrect</p> <p>No</p> <p>Correct</p> <p>Sequencer uptime is verified</p> <p>Explanation</p> <p>Old price data may be used if the protocol is not aware that the sequencer is down.</p> <p>Links</p> <ul> <li>Chainlink recommended sequencer check code</li> </ul>"},{"location":"layer2/#2-is-blocknumber-used-anywhere","title":"2. Is block.number used anywhere?","text":"<p>Incorrect</p> <p>Yes, block.number is used on Optimism, Arbitrum, or a similar L2</p> <p>Correct</p> <p>No, <code>block.timestamp</code> is used instead of <code>block.number</code></p> <p>Explanation</p> <p>Block production is not constant on L2 chains, meaning <code>block.timestamp</code> is a better choice than <code>block.number</code> in most cases.</p> <p>Links</p> <ul> <li>block.timestamp recommended by Optimism docs</li> <li>block.timestamp recommended by Arbitrum docs</li> </ul>"},{"location":"layer2/#3-is-create2-used-in-contracts-deployed-to-zkevms-like-zksync-era","title":"3. Is CREATE2 used in contracts deployed to zkEVMs (like zkSync Era)?","text":"<p>Incorrect</p> <p>Yes</p> <p>Correct</p> <p>No</p> <p>Explanation</p> <p>zkEVMs can compute CREATE2 addresses differently than on ETH mainnet. Code copied from ETH mainnet to calculate the address of the contract deployed with CREATE2 may not work as expected.</p> <p>Links</p> <ul> <li>Tweet from pcaversaccio describing the difference</li> </ul>"},{"location":"layer2/#4-if-deployed-on-gnosis-chain-xdai-are-reentrant-tokens-considered","title":"4. If deployed on Gnosis chain (xDAI), are reentrant tokens considered?","text":"<p>Incorrect</p> <p>No</p> <p>Correct</p> <p>Yes</p> <p>Explanation</p> <p>Gnosis Chain cross-chain tokens have a <code>onTokenTransfer()</code> hook that enabled reentrancy. The Gnosis bridge creates a ERC677 tokens on Gnosis Chain for these tokens, which means protocols like Compound Finance cannot be used on xDAI safely unless modified to protect against reentrancy.</p> <p>Links</p> <ul> <li>Gnosis bridge details</li> <li>Hundred Finance and Agave Finance hacks</li> </ul>"},{"location":"layer2/#5-do-any-token-addresses-consider-if-a-token-is-bridged-or-native","title":"5. Do any token addresses consider if a token is bridged or native?","text":"<p>Incorrect</p> <p>A difference between bridged or native tokens was not considered.</p> <p>Correct</p> <p>Yes, the different types of tokens were considered and the correct choice is made.</p> <p>Explanation</p> <p>Some tokens, like USDC, have a bridged and native form. For example, USDC.e on Arbitrum, Avalanche, and Optimism is the bridged form of USDC. Circle launched a native USDC on these chains after the bridged tokens already existed. If the protocol involves any tokens that may be bridged, it is important to consider which token address to use.</p> <p>Links</p> <ul> <li>Circle announcement of Optimism native USDC</li> <li>Circle announcement of Arbitrum native USDC</li> </ul>"},{"location":"layer2/#6-if-deployed-on-blast-chain-is-it-claiming-fees","title":"6. If deployed on Blast chain, is it claiming fees?","text":"<p>Incorrect</p> <p>No.</p> <p>Correct</p> <p>Yes, deployed contracts are configured to receive and claim gas from Blast.</p> <p>Explanation</p> <p>Blast redirects sequencer fees to the DApps that induced them, allowing smart contract developers to have an additional source of revenue. The contracts have to be configured to receive and claim gas fees.</p> <p>Links</p> <ul> <li>Blast docs for receiving and claiming fees</li> </ul>"},{"location":"oracle/","title":"Oracle price data","text":"<p>Oracles are a common choice to receive price data for assets. The price data from oracles can be harder to manipulate than price data from a DeFi protocol's swap pool, but there are common oracle integration issues that should be kept in mind.</p> <p>Other resources:</p> <ul> <li>Market Manipulation vs. Oracle Exploits</li> </ul>"},{"location":"oracle/#1-is-the-spot-price-of-a-pool-used","title":"1. Is the spot price of a pool used?","text":"<p>Incorrect</p> <p>Yes, spot price is used and it can be manipulated by flashloans</p> <p>Correct</p> <p>A decentralized oracle (Chainlink, Band, UMA, etc.), Uniswap v3 TWAP or similar</p> <p>Explanation</p> <p>Flashloan price manipulation has caused many protocol hacks, making price manipulation hacks one of the most common attack vectors</p> <p>Links</p> <ul> <li>samczsun's oracle price guide</li> </ul>"},{"location":"oracle/#2-are-variable-decimals-for-different-token-pair-price-feeds-accounted-for","title":"2. Are variable decimals for different token pair price feeds accounted for?","text":"<p>Incorrect</p> <p>No, a constant decimals value is hardcoded</p> <p>Correct</p> <p>Yes</p> <p>Explanation</p> <p>Incorrect decimals can lead to accounting errors</p> <p>Links</p> <ul> <li>USD/AMPL Chainlink price feed has 18 decimals, not 8 decimals</li> </ul>"},{"location":"oracle/#3-if-uniswap-v3-twap-is-used-for-price-data-is-post-merge-pos-manipulation-accounted-for","title":"3. If Uniswap v3 TWAP is used for price data, is post-merge PoS manipulation accounted for?","text":"<p>Incorrect</p> <p>No, TWAP is fully trusted</p> <p>Correct</p> <p>Yes</p> <p>Explanation</p> <p>Incorrect decimals can lead to accounting errors</p> <p>Links</p> <ul> <li>Euler oracle manipulation tool and usage instructions</li> <li>Uniswap analysis of TWAP manipulation in PoS</li> </ul>"},{"location":"oracle/#chainlink-oracle","title":"Chainlink Oracle","text":""},{"location":"oracle/#1-is-a-deprecated-chainlink-function-used-such-as-latestanswer-latestround-or-gettimestamp","title":"1. Is a deprecated Chainlink function used, such as <code>latestAnswer()</code>, <code>latestRound()</code>, or <code>getTimestamp()</code>?","text":"<p>Incorrect</p> <p>Yes</p> <p>Correct</p> <p>No</p> <p>Explanation</p> <p>Deprecated functions may not be supported in the future, which could cause a denial of service</p> <p>Links</p> <ul> <li>Chainlink deprecated functions</li> </ul>"},{"location":"oracle/#2-is-there-proper-validation-of-latestrounddata","title":"2. Is there proper validation of <code>latestRoundData()</code>?","text":"<p>Incorrect</p> <p>No</p> <p>Correct</p> <p>Yes, price is confirmed to be in the range of minAnswer and maxAnswer limits, the timestamp of the latest answer is checked against zero and a stale feed threshold that depends on the update frequency of the oracle for each specific token</p> <p>Explanation</p> <p>Insufficient validation of oracle can lead to the acceptance of bad data</p> <p>Links</p> <ul> <li>Compound fork bad debt accumulation during Luna crash</li> </ul>"},{"location":"oracle/#3-is-the-price-query-in-a-trycatch","title":"3. Is the price query in a try/catch?","text":"<p>Incorrect</p> <p>No</p> <p>Correct</p> <p>Yes, <code>latestRoundData</code> call is in a try/catch block</p> <p>Explanation</p> <p>Access to price feed data may be removed due to the multisig ownership of Chainlink's EACAggregatorProxy contract which is queried for price data. If uptime is a key part of a protocol's design and the Chainlink multisig is not considered a trusted entity, a backup mode of operation should exist in the <code>catch</code> block of the try/catch price query to handle the edge case where the primary Chainlink price feed is not available.</p> <p>Links</p> <ul> <li>\"ChainLink Price Feeds\" section of OpenZeppelin post</li> </ul>"},{"location":"proxies/","title":"Proxies and Upgradeable Code","text":"<p>Proxies are a common tool to allow for smart contract code to receive upgrades. A proxy contract acts as a pointer to a logic contract using delegatecall, and the logic contract contains the implementation logic. If the proxy contract is modified to point to a different logic contract address, the implementation logic is changed.</p> <p>Other resources:</p> <ul> <li>OpenZeppelin Proxy Pattern</li> <li>yAcademy Proxies Research</li> </ul>"},{"location":"proxies/#1-is-the-uups-proxy-initialized","title":"1. Is the UUPS proxy initialized?","text":"<p>Incorrect</p> <p>No</p> <p>Correct</p> <p>Yes</p> <p>Explanation</p> <p>An uninitialized proxy can be initialized by anyone. The user that calls the initialize function is granted special privileges for the proxy contract.</p> <p>Links</p> <ul> <li>Wormhole, largest bug bounty</li> <li>Aave v2</li> <li>Agave v2 (Aave fork)</li> <li>Teller</li> <li>Harvest Finance</li> </ul>"},{"location":"proxies/#2-does-the-logic-contract-behind-the-proxy-contain-selfdestruct","title":"2. Does the logic contract behind the proxy contain selfdestruct?","text":"<p>Incorrect</p> <p>Yes</p> <p>Correct</p> <p>No, <code>selfdestruct</code> is not found in the contracts or the contract is not a logic contract behind a proxy contract</p> <p>Explanation</p> <p>If the logic contract behind a proxy contains <code>selfdestruct</code>, the proxy can be deleted, which can cause a denial of service. If a metamorphic contract created with CREATE2 contains <code>selfdestruct</code>, then the contract code can be replaced in a similar way to upgrading code behind a proxy.</p> <p>Links</p> <ul> <li>Parity Wallet hack and OpenZeppelin writeup (note: the contract was initialized but had no protection against a second call to <code>initialize()</code>)</li> <li>Paradigm CTF 2021 \"Vault\"</li> <li>Ethernaut Level 25 \"Motorbike\"</li> <li>OpenZeppelin proxy vulnerability</li> <li>iosiro blog post about OpenZeppelin vulnerability</li> </ul>"},{"location":"proxies/#3-is-the-contract-not-necessarily-a-proxy-contract-created-with-create2-or-create3-and-the-contract-contains-selfdestruct","title":"3. Is the contract (not necessarily a proxy contract) created with CREATE2 or CREATE3 and the contract contains selfdestruct?","text":"<p>Incorrect</p> <p>Yes</p> <p>Correct</p> <p>No, <code>selfdestruct</code> is not found in the contracts or the contract was not created with CREATE2 or CREATE3</p> <p>Explanation</p> <p>A CREATE2 or CREATE3 contract that contains selfdestruct can be destroyed and replaced with a new contract at the same address. If a metamorphic contract created with CREATE2 contains <code>selfdestruct</code>, then the contract code can be replaced in a similar way to upgrading code behind a proxy.</p> <p>Links</p> <ul> <li>Rajeev forum post about CREATE2 security implications</li> <li>CertiK metamorphic contract detector tool</li> <li>a16z metamorphic contract detector tool</li> <li>PoC metamorphic contract detector tool</li> </ul>"},{"location":"proxies/#4-does-the-upgraded-logic-contract-have-the-same-state-variable-layout-as-the-contract-it-replaces","title":"4. Does the upgraded logic contract have the same state variable layout as the contract it replaces?","text":"<p>Incorrect</p> <p>No</p> <p>Correct</p> <p>Yes, new state variables are only appended to the list of existing state variables. Even better, the new state variables are filling slots that were already reserved using a pattern like OpenZeppelin contact's storage gap.</p> <p>Explanation</p> <p>If the storage variable layout is changed, a storage collision can happen where the variable names in the upgraded contract to not match the variables that are stored in the corresponding storage slots. The storage layout should always consider inheritance, so flattening the contracts to more easily view the storage variables can sometimes be a useful manual approach. Automated tools can also reveal the storage layout of a contract and help verify that no storage collision happens as a result of a contract upgrade.</p> <p>Links</p> <ul> <li>Furucombo (Related writeups here and here)</li> <li>Audius (Related writeup here)</li> <li>Solidity by Example</li> <li>Ethernaut Level 6 \"Delegation\"</li> <li>Ethernaut Level 16 \"Preservation\"</li> <li>Ethernaut Level 24 \"Puzzle Wallet\"</li> <li>Underhanded Solidity 2020 entry 4 from Jaime Iglesias</li> <li>OpenZeppelin explanation</li> </ul>"}]}